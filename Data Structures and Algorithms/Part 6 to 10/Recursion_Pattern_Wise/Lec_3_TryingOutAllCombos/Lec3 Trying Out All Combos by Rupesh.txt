package Recursion_Pattern_Wise.Lec_3_TryingOutAllCombos;

import java.util.ArrayList;
import java.util.List;

/*Q1 131. Palindrome Partitioning
Medium
Topics
Companies
Given a string s, partition s such that every 
substring
 of the partition is a 
palindrome
. Return all possible palindrome partitioning of s.

 

Example 1:

Input: s = "aab"
Output: [["a","a","b"],["aa","b"]]
Example 2:

Input: s = "a"
Output: [["a"]]
 

Constraints:

1 <= s.length <= 16
s contains only lowercase English letters.
Seen this question in a real interview before?
1/5
Yes
No
Accepted
901.9K
Submissions
1.3M
Acceptance Rate
69.4% */
public class Palindrome_Paritioning {
    public List<List<String>> partition(String s) {
        List<List<String>> ans = new ArrayList<>();
        int n = s.length();
        recurPalPartition(s,n,0,new ArrayList<String>(), ans);
        return ans;
    }
    //DFS approach
    private void recurPalPartition(String s, int n, int i, ArrayList<String> currSet, List<List<String>> ans) {
        if(i==n){// Base: last parition always at end of string
            ans.add(new ArrayList<>(currSet));
            return;
        }
        //Iterate through s checking for pals. and finding valid paritions
        for(int j=i; j<n;j++){
            //check if s[i to j] is pal. or not
            if(isPal(s,i,j)){
                // if yes, add to current partion
                String sub=s.substring(i, j+1);
                currSet.add(sub);
                // propagate further into recursion depth to find next partiions
                recurPalPartition(s, n, j+1, currSet, ans);
                // Backtrack by removing to explore next parallel possibility
                currSet.remove(currSet.size()-1);
            }
        }
    }
    private boolean isPal(String s, int i, int j) {
       //2 ptr. approach
       //keep a L at atart and R at end, go to mid while checking for matches
       int L=i; int R=j;
       while(L<=R)
       {if(s.charAt(L++)!=s.charAt(R--)){return false;} 
        }
        return true;
    }
}
package Recursion_Pattern_Wise.Lec_3_TryingOutAllCombos;

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;

/*Q3 51. N-Queens
Hard
Topics
Companies
The n-queens puzzle is the problem of placing n queens on an n x n chessboard such that no two queens attack each other.

Given an integer n, return all distinct solutions to the n-queens puzzle. You may return the answer in any order.

Each solution contains a distinct board configuration of the n-queens' placement, where 'Q' and '.' both indicate a queen and an empty space, respectively.

 

Example 1:


Input: n = 4
Output: [[".Q..","...Q","Q...","..Q."],["..Q.","Q...","...Q",".Q.."]]
Explanation: There exist two distinct solutions to the 4-queens puzzle as shown above
Example 2:

Input: n = 1
Output: [["Q"]]
 

Constraints:

1 <= n <= 9
Seen this question in a real interview before?
1/5
Yes
No
Accepted
738.4K
Submissions
1.1M
Acceptance Rate
68.7% */
public class N_Queens {
    public List<List<String>> solveNQueens(int n) {
        List<List<String>> ans = new ArrayList<>();
        char[][]board=new char[n][n];
        //fill whole board all places as blank marker
        for(int i=0;i<n;i++){
            for(int j=0;j<n;j++){
                board[i][j]='b';//b==blank
            }
        }
        //Create Hash Tables for storing lines of attack already occupied
        int[]lft=new int[n];
        int[]lftLoDiag=new int[n+n-1];
        int[]lftHiDiag=new int[n+n-1];
        //
        recurDFS(0,board,ans, n,lft,lftLoDiag,lftHiDiag); return ans;
    }

    private void recurDFS(int col, char[][] board, List<List<String>> ans, int n, int[]lft, int[]lftLoDiag, int[]lftHiDiag) {
        //check if beyond boards length
        if(col==n){
            ans.add(construct(board));
            return;
        }
        //Search Rows
        for(int row=0;row<n;row++){
            //if Q for the curr col is placeable in in this row
            if(validate(board,n, row,col,lft,lftLoDiag,lftHiDiag)){
                //put Q of curr col in that row
                board[row][col]='Q';
                //update hash tables
                lft[row]=1;
                lftLoDiag[row+col]=1;
                lftHiDiag[(n-1-row)+col]=1;
                //search next col Q place
                recurDFS(col+1, board, ans, n, lft, lftLoDiag, lftHiDiag);
                //Backtrack to previous state to enable exploring alternate paths in recursion tree
                board[row][col]='b';
                //revert hash tables
                lft[row]=0;
                lftLoDiag[row+col]=0;
                lftHiDiag[(n-1-row)+col]=0;
            }
        }
    }

    private List<String> construct(char[][] board) {
        List<String>currSet=new LinkedList<String>();
        for (int i = 0; i < board.length; i++) {
            String s = new String(board[i]);
            currSet.add(s);
        }
        return currSet;
    }

    private boolean validate(char[][] board, int n, int row, int col, int[] lft, int[] lftLoDiag, int[] lftHiDiag) {
        //See if given (row,col) is in line of attack of any other Q
        //check left attacks
        if(lft[row]!=0) return false;
        //chk diag attacks
        if(lftLoDiag[row+col]!=0||lftHiDiag[(n-row)+col]!=0) return false;
        //else
        return true;
    }
    
}
/*
//lc submission
class Solution {
  public List<List<String>> solveNQueens(int n) {
        List<List<String>> ans = new ArrayList<>();
        char[][]board=new char[n][n];
        //fill whole board all places as blank marker
        for(int i=0;i<n;i++){
            for(int j=0;j<n;j++){
                board[i][j]='.';//b==blank
            }
        }
        //Create Hash Tables for storing lines of attack already occupied
        int[]lft=new int[n];
        int[]lftLoDiag=new int[n+n-1];
        int[]lftHiDiag=new int[n+n-1];
        //
        recurDFS(0,board,ans, n,lft,lftLoDiag,lftHiDiag); return ans;
    }

    private void recurDFS(int col, char[][] board, List<List<String>> ans, int n, int[]lft, int[]lftLoDiag, int[]lftHiDiag) {
        //check if beyond boards length
        if(col==n){
            ans.add(construct(board));
            return;
        }
        //Search Rows
        for(int row=0;row<n;row++){
            //if Q for the curr col is placeable in in this row
            if(validate(board,n, row,col,lft,lftLoDiag,lftHiDiag)){
                //put Q of curr col in that row
                board[row][col]='Q';
                //update hash tables
                lft[row]=1;
                lftLoDiag[row+col]=1;
                lftHiDiag[(n-1-row)+col]=1;
                //search next col Q place
                recurDFS(col+1, board, ans, n, lft, lftLoDiag, lftHiDiag);
                //Backtrack to previous state to enable exploring alternate paths in recursion tree
                board[row][col]='.';
                //revert hash tables
                lft[row]=0;
                lftLoDiag[row+col]=0;
                lftHiDiag[(n-1-row)+col]=0;
            }
        }
    }

    private List<String> construct(char[][] board) {
        List<String>currSet=new LinkedList<String>();
        for (int i = 0; i < board.length; i++) {
            String s = new String(board[i]);
            currSet.add(s);
        }
        return currSet;
    }

    private boolean validate(char[][] board, int n, int row, int col, int[] lft, int[] lftLoDiag, int[] lftHiDiag) {
        //See if given (row,col) is in line of attack of any other Q
        //check left attacks
        if(lft[row]!=0) return false;
        //chk diag attacks
        if(lftLoDiag[row+col]!=0||lftHiDiag[(n-1-row)+col]!=0) return false;
        //else
        return true;
    }
} */
package Recursion_Pattern_Wise.Lec_3_TryingOutAllCombos;

import java.util.ArrayList;
import java.util.List;

/*Q4 Rat in a Maze Problem - I
MediumAccuracy: 35.75%Submissions: 249K+Points: 4
Be the comment of the day in POTD and win a GfG T-Shirt!
Solve right now

banner
Consider a rat placed at (0, 0) in a square matrix of order N * N. It has to reach the destination at (N - 1, N - 1). Find all possible paths that the rat can take to reach from source to destination. The directions in which the rat can move are 'U'(up), 'D'(down), 'L' (left), 'R' (right). Value 0 at a cell in the matrix represents that it is blocked and rat cannot move to it while value 1 at a cell in the matrix represents that rat can be travel through it.
Note: In a path, no cell can be visited more than one time. If the source cell is 0, the rat cannot move to any other cell.

Example 1:

Input:
N = 4
m[][] = {{1, 0, 0, 0},
         {1, 1, 0, 1}, 
         {1, 1, 0, 0},
         {0, 1, 1, 1}}
Output:
DDRDRR DRDDRR
Explanation:
The rat can reach the destination at 
(3, 3) from (0, 0) by two paths - DRDDRR 
and DDRDRR, when printed in sorted order 
we get DDRDRR DRDDRR.
Example 2:
Input:
N = 2
m[][] = {{1, 0},
         {1, 0}}
Output:
-1
Explanation:
No path exists and destination cell is 
blocked.
Your Task:  
You don't need to read input or print anything. Complete the function printPath() which takes N and 2D array m[ ][ ] as input parameters and returns the list of paths in lexicographically increasing order. 
Note: In case of no path, return an empty list. The driver will output "-1" automatically.

Expected Time Complexity: O((3N^2)).
Expected Auxiliary Space: O(L * X), L = length of the path, X = number of paths.

Constraints:
2 ≤ N ≤ 5
0 ≤ m[i][j] ≤ 1

 */
public class Rat_In_Maze {
    //2nd attempt, minor improvements
    public static ArrayList<String> findPath(int[][] m, int n) {
        ArrayList<String> ans = new ArrayList<>();
        if(m[n-1][n-1] != 1) return ans;
        if (m[0][0] != 1) return ans;
        int vis[][] = new int[n][n];
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                vis[i][j] = 0;
            }
        }
        int di[] = {+1, 0, 0, -1};
        int dj[] = {0, -1, +1, 0};
        //if (m[0][0] == 1) 
        recurChk(0, 0, m, n, ans, "", vis, di, dj);
        return ans;
    }

    // i=row, j=col
    private static void recurChk(int i, int j, int[][] m, int n, List<String> ans, String movesSB, int[][] vis, int[] di, int[] dj) {
        if (i == n - 1 && j == n - 1) {
            ans.add(movesSB);
            return;
        }

        char[] dirs = {'D', 'L', 'R', 'U'};
        for (int ind = 0; ind < 4; ind++) {
            int nextrow = i + di[ind];
            int nextcol = j + dj[ind];
            if (nextrow >= 0 && nextrow < n && nextcol >= 0 && nextcol < n && vis[nextrow][nextcol] == 0 && m[nextrow][nextcol] == 1) {
                vis[i][j] = 1;
                recurChk(nextrow, nextcol, m, n, ans, movesSB + dirs[ind], vis, di, dj);
                vis[i][j] = 0;
            }
        }
    }

    public static void main(String[] args) {
        // Test Case 1
        int[][] maze1 = {
            {1, 0, 0, 0},
            {1, 1, 0, 1},
            {1, 1, 0, 0},
            {0, 1, 1, 1}
        };
        System.out.println(findPath(maze1, 4)); // Expected output: [DDRDRR, DRDDRR]

        // Test Case 2
        int[][] maze2 = {
            {1, 0},
            {1, 0}
        };
        System.out.println(findPath(maze2, 2)); // Expected output: []
    }
//first attempt, some mistakes
//     public static ArrayList<String> findPath(int[][] m, int n) {
//         ArrayList<String> ans = new ArrayList<>();
//         //keepa visted matrix;
//         int vis[][]=new int[n][n];
//         for(int i=0;i<n;i++){
//             for(int j=0;j<n;j++){
//                 vis[i][j]=0;
//             }
//         }
//         //to store direction offsets
//         int di[]={+1,0,0,-1};
//         int dj[]={0,-1,+1,0};
//         if(m[0][0]==1) recurChk(0,0,m,n,ans,"",vis,di,dj);
//         return ans;
//     }
//     //i=row,j=col
//     private static void recurChk(int i, int j, int[][] m, int n, List<String> ans, String movesSB, int[][] vis,
//             int[] di, int[] dj) {
//                 //if reach destination, return
//                 if(i==n-1 && j==n-1){
//                     ans.add(new String(movesSB));
//                     return;
//                 }
//                 char[] dirs={'D','L','R','U'};
//                 for(int ind=0; ind<4; ind++){
//                     int nextcol=i+di[ind];
//                     int nextrow=j+dj[ind];
//                     if(nextcol>=0 && nextcol<n && nextrow>=0 && nextcol<n && vis[nextrow][nextcol]==0 && m[nextrow][nextcol]==1){
//                         //mark curr place as visted
//                         vis[i][j]=1;
//                         //explore further after fixing curr place
//                         recurChk(nextrow, nextcol, m, nextrow, ans, (movesSB + dirs[ind]), vis, di, dj);
//                         //Backtracking, umark and unfix curr place
//                         vis[i][j]=0;
//                     }
//                 } 
//     }

//Corrected 1st attempt, refer for comments here
// //i=row,j=col
// private static void recurChk(int i, int j, int[][] m, int n, List<String> ans, String movesSB, int[][] vis,
// int[] di, int[] dj) {
//     //if reach destination, return
//     if(i==n-1 && j==n-1){
//         ans.add(movesSB);
//         return;
//     }
//     char[] dirs={'D','L','R','U'};
//     for(int ind=0; ind<4; ind++){
//         int nextrow=i+di[ind];
//         int nextcol=j+dj[ind];
//         // if(nextcol>=0 && nextcol<n && nextrow>=0 && nextcol<n && vis[nextrow][nextcol]==0 && m[nextrow][nextcol]==1){
//         if (nextrow >= 0 && nextrow < n && nextcol >= 0 && nextcol < n && vis[nextrow][nextcol] == 0 && m[nextrow][nextcol] == 1) {

//             //mark curr place as visted
//             vis[i][j]=1;
//             //explore further after fixing curr place
//             recurChk(nextrow, nextcol, m, n, ans, (movesSB + dirs[ind]), vis, di, dj);
//             //Backtracking, umark and unfix curr place
//             vis[i][j]=0;
//         }
//     } 
// }
}
package Recursion_Pattern_Wise.Lec_3_TryingOutAllCombos;
import java.util.HashMap;
/*Q5 139. Word Break
Medium
Topics
Companies
Given a string s and a dictionary of strings wordDict, return true if s can be segmented into a space-separated sequence of one or more dictionary words.

Note that the same word in the dictionary may be reused multiple times in the segmentation.

 

Example 1:

Input: s = "leetcode", wordDict = ["leet","code"]
Output: true
Explanation: Return true because "leetcode" can be segmented as "leet code".
Example 2:

Input: s = "applepenapple", wordDict = ["apple","pen"]
Output: true
Explanation: Return true because "applepenapple" can be segmented as "apple pen apple".
Note that you are allowed to reuse a dictionary word.
Example 3:

Input: s = "catsandog", wordDict = ["cats","dog","sand","and","cat"]
Output: false
 

Constraints:

1 <= s.length <= 300
1 <= wordDict.length <= 1000
1 <= wordDict[i].length <= 20
s and wordDict[i] consist of only lowercase English letters.
All the strings of wordDict are unique.
Seen this question in a real interview before?
1/5
Yes
No
Accepted
1.7M
Submissions
3.6M
Acceptance Rate
46.9% */
import java.util.List;

public class Word_Break {
    public boolean wordBreak(String s, List<String> wordDict) {
	// for memoization
        HashMap<String,Boolean> dp= new HashMap<>();
        return canConstruct(s, wordDict, dp);
    }
    
    public boolean canConstruct(String targetSub,List<String> words, HashMap<String,Boolean> dp)
    {
	
	    // if answer already cached, return it
        if(dp.containsKey(targetSub))
            return dp.get(targetSub);
			
		// if targetSub string is empty
		// it can always be constructed by taking no elems. from Dict.
        // taking no elems.==taking empty or null string
        if(targetSub.isEmpty())
            return true;
			
		// for each and every word in the Dict.
        for(String word: words)
        {
		    // if the targetSub starts with the given word
            if(targetSub.startsWith(word))
            {
			    // and it is possible to construct the rest of the string
			    // from the words in the Dict.
                if(canConstruct(targetSub.substring(word.length()),words, dp))
                {
				
				    // save and return true
                    dp.put(targetSub, true);
                    return true;
                }
            }
        }
		
		// if it was not possible to construct the targetSub from words from the Dict.
		// save and return false to the previous call
        dp.put(targetSub,false);
        return false;
    }
    // public boolean wordBreak(String s, List<String> wordDict) {

    //     //first attempt
    //     // int n= s.length();
    //     // //char[] c=s.toCharArray();
    //     // boolean [] dp=new boolean[n+1];
    //     // //dp[0] = true;
    //     // int l=0; int r=0;
    //     // while(r!=n){
    //     //     String sub=s.substring(l, r+1);
    //     //     String start=s.substring(0, r+1);
    //     //     boolean flag=false;
    //     //     for(int i=0;i<wordDict.size();i++){
    //     //         if((wordDict.get(i).equals(sub) && dp[l]==true)||wordDict.get(i).equals(start)){
    //     //             flag=true;
    //     //             dp[r]=true;
    //     //         }
    //     //     }
    //     //     if(flag==true){
    //     //         l=r+1;
    //     //     }
    //     //     r++;
    //     // } return dp[n];
        
    // }
    public static void main(String[] args) {
        Word_Break wb = new Word_Break();

        // Test Case 1
        System.out.println(wb.wordBreak("leetcode", List.of("leet", "code"))); // Expected output: true

        // Test Case 2
        System.out.println(wb.wordBreak("applepenapple", List.of("apple", "pen"))); // Expected output: true

        // Test Case 3
        System.out.println(wb.wordBreak("catsandog", List.of("cats", "dog", "sand", "and", "cat"))); // Expected output: false
    }
}
//LC forum codes, for revising later on
/*4 different ways to solve this with detailed explanation.

DonaldTrump
2349
18871
Dec 21, 2016



/*
 SOLUTION 1: bfs
    Idea is to try to chop off prefix of s that is in the dict
    enqueue the left-over of each chop off
    if there is a time the left over happens to be in the dict as well
        we know word is breakable, b/c all the previous chops are all in the dict
    otherwise the original world is not breakable.
    
    we can use a set to store all the leftovers that we have tried, to avoid enqueue the 
    same leftover multiple times.

*/
// public class Solution {
//     public boolean wordBreak(String s, Set<String> wordDict) {
//         int index = 0;
//         Queue<String> queue = new LinkedList<String>();
//         queue.offer(s);
//         Set<String> visited = new HashSet<String>();
//         while(!queue.isEmpty()){
//             String candidate = queue.poll();
//             if(wordDict.contains(candidate)) return true;
//             for(int i = 0; i < candidate.length(); i++){
//                 String chop = candidate.substring(0,i);
//                 String next = candidate.substring(i, candidate.length());
//                 if(!visited.contains(next) && wordDict.contains(chop)){
//                     next = candidate.substring(i, candidate.length());
//                     queue.offer(next);
//                     visited.add(next);
//                 }
//             }
//         }
//         return false;
//     }
// }

/* SOLUTION 2: dfs
    use a set to record the substring (i, s.length) that is not breakable
    start from the front, try to see if the substring (0,i) is in the dict,
    if so, recursively check if there is a way to break (i, s.length)
    
    
public class Solution {
    public boolean wordBreak(String s, Set<String> wordDict) {
        if(s.length() == 0) return false;
        Set<Integer> set = new HashSet<Integer>();
        return helper(s, 0, set, wordDict);
    }
    
    private boolean helper(String s, int index, Set<Integer> set, Set<String> dict){
        if(index == s.length()) return true;
        for(int i = index + 1; i <= s.length(); i++){
            if(set.contains(i)) continue;
            if(dict.contains(s.substring(index, i))){
                 if (helper(s, i, set, dict)) return true;
                 set.add(i);
            }
        }
        return false;
    }
}


/* SOLUTION 3: dp
    dp[i] represents if substring (0,i) is breakable.
    for each longer substring, we just need to check 

public class Solution {
    public boolean wordBreak(String s, Set<String> wordDict) {
        if(s.length() == 0) return false;
        boolean[] breakable = new boolean[s.length() + 1];
        breakable[0] = true;
        for(int i = 1; i <= s.length(); i++){
            for(int j = 0; j < i; j++){
                if(breakable[j] && wordDict.contains(s.substring(j, i))){
                    breakable[i] = true;
                    break;
                }
            }
        }
        //for(boolean b : breakable) System.out.print(b + ", ");
        return breakable[s.length()];
    }
}
*/

/* SOLUTION 4: TRIE + MAP  


public class Solution {
    public boolean wordBreak(String s, Set<String> wordDict) {
        Trie trie = new Trie();
        for(String d : wordDict){
            trie.insert(d);
        }
        List<String> prefix = findPrefix(trie, s);
        Map<String, Boolean> map = new HashMap<String, Boolean>();
        for(String split : prefix){
            if(canBeSplitted(trie, s.replaceFirst(split, ""), map)){
                map.put(split, true);
                return true;
            }
        }
        return false;   
    }
    
    private boolean canBeSplitted(Trie root, String input, Map<String, Boolean> map){
        if(map.containsKey(input)) return map.get(input);
        if(root.search(input) || input.length() == 0) return true;
        List<String> prefix = findPrefix(root, input);
        for(String s : prefix){
            String copy = new String(input);
            if(canBeSplitted(root, copy.replaceFirst(s, ""), map)){
                map.put(input, true);
                return true;
            } 
        }
        map.put(input, false);
        return false;
    }
    
    private List<String> findPrefix(Trie root, String input){
        char[] split = input.toCharArray();
        List<String> result = new ArrayList<String>();
        TrieNode pointer = root.root;
        for(int i = 0; i < split.length; i++){
            pointer = pointer.next[split[i] - 'a'];
            if(pointer == null) break;
            if(pointer.word != null) result.add(pointer.word);
        }
        return result;
    }    

    class TrieNode {
    
        public String word;
        public TrieNode[] next;
        public TrieNode() {
            word = null;
            next = new TrieNode[26];
        }
    }

    public class Trie {
        private TrieNode root;
    
        public Trie() {
            root = new TrieNode();
        }
    
        public void insert(String word) {
            TrieNode pointer = root;
            for(int i = 0; i < word.length(); i++){
                if(pointer.next[word.charAt(i) - 'a'] == null){
                    pointer.next[word.charAt(i) - 'a'] = new TrieNode();
                }
                pointer = pointer.next[word.charAt(i) - 'a'];
            }
            pointer.word = word;
        }
    
        public boolean search(String word) {
            TrieNode pointer = root;
            if(root.word != null && root.word.equals(word)) return true;
            for(int i = 0; i < word.length(); i++){
                if(pointer.next[word.charAt(i) - 'a'] == null) return false;
                pointer = pointer.next[word.charAt(i) - 'a'];
            }
            if(pointer.word == null) return false;
            return pointer.word.equals(word);
        }
    
    }    
    
}*/ //
// [Pyhon] dfs, using lru_cache, explained

// DBabichev
// 100 Days Badge 2023
// 41898
// 1767
// Sep 29, 2020
// Let dfs(k) be a possibility to split string s[k:] into words from wordSet. Then to check if word s[k:] can be splitted, we need to check if for some i word s[k:i] in our wordSet and if s[i:] can be splitted, which is dfs(i).

// Complexity: let T be the maximum length of word in our wordSet. Then we need O(T) time to check if word in our set, so we have overall O(n^2T) complexity. Space complexity is O(n +Tn) : to keep our cache and to keep our set of wordSet

// class Solution:
//     def wordBreak(self, s, wordDict):
//         wordSet = set(wordDict)
//         n = len(s)
   
//         @lru_cache(None)
//         def dfs(k):
//             if k == n: return True
//             for i in range(k + 1, n + 1):
//                 if s[k:i] in wordSet and dfs(i):
//                     return True        
//             return False
        
//         return dfs(0)
// Further discussion: Another approach is to use KMP for each of the m words and create n x n table Mem, where Mem[i][j] is equal to 1 if s[i:j] is in our Dict.. The complexity to generate Mem table is O(mn) and O(n^2) to update dp. Finally, we have O(n^2 + nm) time and O(n^2) memory.

// One more approach is to use Tries to preprocess our dictionary with O(mk) time, where k is the average length of words. Then we can fill dp table in O(n^2) time (CHECK, I am not 100 percent sure). Finally, we have O(mk + n^2) time and O(mk) memory.

// If you have any questions, feel free to ask. If you like solution and explanations, please Upvote!

// Previous
// Fastest JavaScript BFS 44ms
// Next
// Accepted Java Solution
// Comments (2)

// Sort by:Best
// Type comment here... (Markdown supported)
// Preview
// Comment

// cy171
// Annual Badge 2023
// Apr 08, 2023
// python code using tire.

// def wordBreak(self, s: str, wordDict: List[str]) -> bool:
//     head = {}
//     for word in wordDict:
//         dic = head
//         for l in word:
//             dic = dic.setdefault(l,{}) 
//         dic["*"] = True

//     @lru_cache
//     def dfs(i):
//         dic = head
//         for j, l in enumerate(s[i:], start=i):
//             if dic.get("*", False) and dfs(j):
//                 return True
//             if l in dic:
//                 dic = dic[l]
//             else:
//                 return False
//         return dic.get("*", False)
//     return dfs(0)
// 0
// Reply
//https://leetcode.com/problems/word-break/solutions/4453481/conquering-dp-mastering-word-break-with-expert-strategies-beginner-friendly
package Recursion_Pattern_Wise.Lec_3_TryingOutAllCombos;
/*Q6 M-Coloring Problem
MediumAccuracy: 34.42%Submissions: 117K+Points: 4
Be the comment of the day in POTD and win a GfG T-Shirt!
Solve right now

banner
Given an undirected graph and an integer M. The task is to determine if the graph can be colored with at most M colors such that no two adjacent vertices of the graph are colored with the same color. Here coloring of a graph means the assignment of colors to all vertices. Print 1 if it is possible to colour vertices and 0 otherwise.

Example 1:

Input:
N = 4
M = 3
E = 5
Edges[] = {(0,1),(1,2),(2,3),(3,0),(0,2)}
Output: 1
Explanation: It is possible to colour the
given graph using 3 colours.
Example 2:

Input:
N = 3
M = 2
E = 3
Edges[] = {(0,1),(1,2),(0,2)}
Output: 0
Your Task:
Your task is to complete the function graphColoring() which takes the 2d-array graph[], the number of colours and the number of nodes as inputs and returns true if answer exists otherwise false. 1 is printed if the returned value is true, 0 otherwise. The printing is done by the driver's code.
Note: In Example there are Edges not the graph.Graph will be like, if there is an edge between vertex X and vertex Y graph[] will contain 1 at graph[X-1][Y-1], else 0. In 2d-array graph[ ], nodes are 0-based indexed, i.e. from 0 to N-1.Function will be contain 2-D graph not the edges.

Expected Time Complexity: O(MN).
Expected Auxiliary Space: O(N).

Constraints:
1 ≤ N ≤ 20
1 ≤ E ≤ (N*(N-1))/2
1 ≤ M ≤ N */
public class M_coloring {
    // Function to determine if graph can be coloured with at most M colours
    // such
    // that no two adjacent vertices of graph are coloured with same colour.
    public boolean graphColoring(boolean g[][], int m, int n) {
        // Your code here
        if(m>=n) return true;
        if(n>0 && m==0) return false;
        int color[]=new int[n];//store color of each node
        if(canColor(0, g, m, n, color)) return true;
        return false;
    }

    private boolean canColor(int Node, boolean[][] g, int m, int n, int[] color) {
        if(Node==n) return true; // reach beyond last node == have colored all nodes
        for(int i=1; i<=m;i++){
            if(NeighbourCheck(Node, g, m,n,i, color)){
                color[Node]=i;
                if(canColor((Node+1), g, m, n, color)) return true;
                color[Node]=0; // Backtrack
            }
        } return false;
    }
    private boolean NeighbourCheck(int node, boolean[][] g, int m, int n, int colorToCheck, int[] color) {
        // Srch all neighbor nodes
        for (int j = 0; j < n; j++) {
            // If there's an edge between node and j and j has the same color, return false
            if (g[node][j] && color[j] == colorToCheck) return false;
        }
        return true;
    }
    // private boolean NeighbourCheck(int node, boolean[][] g, int m, int n, int i, int[] color) {
    //     //srch all nbr nodes
    //     for(int j=0; j<g[node].length; j++){
    //         if(color[j]==i) return false;
    //     } return true;
    // }
}
package Recursion_Pattern_Wise.Lec_3_TryingOutAllCombos;
/*Q7 
Code
Testcase
Testcase
Test Result
37. Sudoku Solver
Hard
Topics
Companies
Write a program to solve a Sudoku puzzle by filling the empty cells.

A sudoku solution must satisfy all of the following rules:

Each of the digits 1-9 must occur exactly once in each row.
Each of the digits 1-9 must occur exactly once in each column.
Each of the digits 1-9 must occur exactly once in each of the 9 3x3 sub-boxes of the grid.
The '.' character indicates empty cells.

 

Example 1:


Input: board = [["5","3",".",".","7",".",".",".","."],["6",".",".","1","9","5",".",".","."],[".","9","8",".",".",".",".","6","."],["8",".",".",".","6",".",".",".","3"],["4",".",".","8",".","3",".",".","1"],["7",".",".",".","2",".",".",".","6"],[".","6",".",".",".",".","2","8","."],[".",".",".","4","1","9",".",".","5"],[".",".",".",".","8",".",".","7","9"]]
Output: [["5","3","4","6","7","8","9","1","2"],["6","7","2","1","9","5","3","4","8"],["1","9","8","3","4","2","5","6","7"],["8","5","9","7","6","1","4","2","3"],["4","2","6","8","5","3","7","9","1"],["7","1","3","9","2","4","8","5","6"],["9","6","1","5","3","7","2","8","4"],["2","8","7","4","1","9","6","3","5"],["3","4","5","2","8","6","1","7","9"]]
Explanation: The input board is shown above and the only valid solution is shown below:


 

Constraints:

board.length == 9
board[i].length == 9
board[i][j] is a digit or '.'.
It is guaranteed that the input board has only one solution.
Seen this question in a real interview before?
1/5
Yes
No
Accepted
600.2K
Submissions
974.7K
Acceptance Rate
61.6% */
public class Solve_Sodoku {
    public void solve_Sudoku(char[][] board) {
        solveSudoku(board);
    }

    public boolean solveSudoku(char[][] board) {
        // tail recursion soln. -> recursive case before base case check
        // iterate entire board for blanks 
        for (int i = 0; i < 9; i++) {
            for (int j = 0; j < 9; j++) {
            // when blank found
                if (board[i][j] == '.') {
                    // check if any char fits
                    for (char c = '1'; c <= '9'; c++) {
                        if (possible(c,i,j,board)==true) {
                            // if char fits put it there
                            board[i][j] = c;
                            // recursively calls for next blanks, explore this possibility with curent char fixed
                            if(solveSudoku(board)==true) return true;
                            // backtrack, unfix current char 
                            //only if curr char not lead to soln. that satify all rules
                            board[i][j] = '.';
                        }
                    } return false;// no no. works to avoid breaking some rule
                }
            }
        } return true;// if no blanks found, Base case
    }

    private boolean possible(char c, int row, int col, char[][] board) {
        for (int i = 0; i < 9; i++) {
            if (board[i][col] == c)
              return false;
      
            if (board[row][i] == c)
              return false;
      
            if (board[3 * (row / 3) + i / 3][3 * (col / 3) + i % 3] == c)
              return false;
          }
          return true;
    }
    
}
/*
 * //faster soln, in lc forum
 * class Solution {
    public void solveSudoku(char[][] board) {
        // We are going to need to edit our sudoku board
        solve(board, 0, 0);
    }

    public boolean solve(char[][] board, int row, int col) {
        // If the col is 9, that means you've filled out a whole row. Start the search on the next row by resetting column and incrementing the row by 1
        if (col == board[0].length) {
            col = 0;
            row += 1;
        }
        // If you've reached 9, that means you didn't run into any errors with your blocks in the previous rows, so you have a valid solution
        if (row == board.length) {
            return true; 
        }
        // If this piece already has a value, check the next square
        if (board[row][col] != '.') return solve(board, row, col+1);
        // We want to try every number for this block
        for (char num = '1'; num <= '9'; num++) {
            // Self explanatory, don't run this if the number isn't a valid answer
            if (checkIfValid(board, row, col, num)) {
                // Set the value of the current square to the valid num
                board[row][col] = num;
                // Run this algo for the next square over
                boolean solved = solve(board, row, col+1);
                // The only way we can trigger a true is if we got to the end, so if it's true that means we have a solved board so you just keep returning
                if (solved) return true;
                // If our board isn't solved, backtrack and try the next number
                else board[row][col] = '.';
            }
        }
        // You get this when every value of the board is filled, because you don't run anything on it
        // If you get to this step, that means that no values fit, which means the current iteration of the board is wrong so return false and try the previous step again with a different value
        return false;
    }

    public boolean checkIfValid(char[][] board, int row, int col, char value) {
        for (int i = 0; i < board.length; i++) {
            // Check the column for duplicates
            if (board[i][col] == value) return false; 
            // Check the row for duplicates
            if (board[row][i] == value) return false;
        }
        // This generates our "box", for [1, 1] for example, this pair will be the box bound by [0, 2] and [0,2]
        int boxRow = row / 3;
        int boxCol = col / 3;
        for (int i = boxRow * 3; i < (boxRow + 1) * 3; i++) {
            for (int j = boxCol * 3; j < (boxCol + 1) * 3; j++) {
                // Check the box for duplicates
                if (board[i][j] == value) return false;
            }
        }
		// There are no falses, therefore this is a valid number to put on the square
        return true;
    }
}
    //https://leetcode.com/problems/sudoku-solver/solutions/1100767/java-5ms-backtracking-solution-using-dfs-with-line-by-line-explanation/
 */
 package Recursion_Pattern_Wise.Lec_3_TryingOutAllCombos;

import java.util.ArrayList;
import java.util.List;

/*Q8 282. Expression Add Operators
Hard
Topics
Companies
Hint
Given a string num that contains only digits and an integer target, return all possibilities to insert the binary operators '+', '-', and/or '*' between the digits of num so that the resultant expression evaluates to the target value.

Note that operands in the returned expressions should not contain leading zeros.

 

Example 1:

Input: num = "123", target = 6
Output: ["1*2*3","1+2+3"]
Explanation: Both "1*2*3" and "1+2+3" evaluate to 6.
Example 2:

Input: num = "232", target = 8
Output: ["2*3+2","2+3*2"]
Explanation: Both "2*3+2" and "2+3*2" evaluate to 8.
Example 3:

Input: num = "3456237490", target = 9191
Output: []
Explanation: There are no expressions that can be created from "3456237490" to evaluate to 9191.
 

Constraints:

1 <= num.length <= 10
num consists of only digits.
-231 <= target <= 231 - 1
Seen this question in a real interview before?
1/5
Yes
No
Accepted
227.2K
Submissions
568.5K
Acceptance Rate
40.0% */
public class Expression_Add_Operators {
    public List<String> addOperators(String num, int target) {
        List<String> exprsns = new ArrayList<>();
        if (num == null || num.length()==0) return exprsns;
        addOperators(num, target, 0, 0, 0, "", exprsns);
        return exprsns;
    }

    private void addOperators(String s, int k, int index, long currVal, long lastVal, String exprsn, List<String> Ans) {
        //Base
        if (index == s.length()) {
            if (currVal == k) Ans.add(exprsn);
            return;
        }
        for (int i = index; i < s.length(); i++) {
            // Avoid 2nd operad as nos. with leading zero, except '0' alone itself
            if (i != index && s.charAt(index) == '0') break; 
            // can break, as loop run once, next recursive calls take care such that it doesn't stop soln. generation
            long currDigitsVal = Long.parseLong(s.substring(index, i + 1));
            if (index == 0) {
                // if currently at 1st digit only, then don't apply any operator
                addOperators(s, k, i + 1, currDigitsVal, currDigitsVal, exprsn + currDigitsVal, Ans);
            } else {
                // 3  calls with ops. 
                addOperators(s, k, i + 1, currVal + currDigitsVal, currDigitsVal, exprsn + "+" + currDigitsVal, Ans);
                addOperators(s, k, i + 1, currVal - currDigitsVal, -currDigitsVal, exprsn + "-" + currDigitsVal, Ans);
                addOperators(s, k, i + 1, currVal - lastVal + lastVal * currDigitsVal, lastVal * currDigitsVal, exprsn + "*" + currDigitsVal, Ans);
            }
        }
    }
}
/*
// soln on lc forum, that just uses char[] to speed up operations
void dfs(List<String> ret, char[] path, int len, long left, long cur, char[] digits, int pos, int target) {
    if (pos == digits.length) {
        if (left + cur == target) ret.add(new String(path, 0, len));
        return;
    }
    long n = 0;
    int j = len + 1;
    for (int i = pos; i < digits.length; i++) {
        n = n * 10 + digits[i] - '0';
        path[j++] = digits[i];
        path[len] = '+';
        dfs(ret, path, j, left + cur, n, digits, i + 1, target);
        path[len] = '-';
        dfs(ret, path, j, left + cur, -n, digits, i + 1, target);
        path[len] = '*';
        dfs(ret, path, j, left, cur * n, digits, i + 1, target);
        if (digits[pos] == '0') break; 
    }
}
public List<String> addOperators(String num, int target) {
    List<String> ret = new LinkedList<>();
    if (num.length() == 0) return ret;
    char[] path = new char[num.length() * 2 - 1];
    char[] digits = num.toCharArray();
    long n = 0;
    for (int i = 0; i < digits.length; i++) {
        n = n * 10 + digits[i] - '0';
        path[i] = digits[i];
        dfs(ret, path, i + 1, 0, n, digits, i + 1, target);
        if (n == 0) break;
    }
    return ret;
}
    //https://leetcode.com/problems/expression-add-operators/solutions/71897/java-ac-solution-19ms-beat-100-00/
 */