package Arrays.Easy;
// q1
// Largest Element in Array
// BasicAccuracy: 67.48%Submissions: 223K+Points: 1
// Find better job opportunities this summer via Job-A-Thon Hiring Challenge!

import java.util.Arrays;

// banner
// Given an array A[] of size n. The task is to find the largest element in it.
 

// Example 1:

// Input:
// n = 5
// A[] = {1, 8, 7, 56, 90}
// Output:
// 90
// Explanation:
// The largest element of given array is 90.
 

// Example 2:

// Input:
// n = 7
// A[] = {1, 2, 0, 3, 2, 4, 5}
// Output:
// 5
// Explanation:
// The largest element of given array is 5.
 

// Your Task:  
// You don't need to read input or print anything. 
// Your task is to complete the function largest() which takes the array A[] and 
// its size n as inputs and returns the maximum element in the array.

 

// Expected Time Complexity: O(N)
// Expected Auxiliary Space: O(1)

 

// Constraints:
// 1 <= n<= 103
// 0 <= A[i] <= 103
// Array may contain duplicate elements.

public class Max {

    public static void main(String[] args) {
        // way 1- use max variable - O(n) - Best way
        int[] array = {1, 8, 7, 56, 90, 22};
        int max=array[0];
        System.out.println("Original array: " + Arrays.toString(array));
        for(int i=1;i<array.length;i++){
            if(array[i]>max) max=array[i];
        }
        System.out.println("way 1 result ----");
        System.out.println("Largest in array: " + max);

       


        //way 3- use 1 pass of bubble sort - then gib last elem - O(1n) - vey imp.

        for(int i=0;i<1;i++) //only 1 pass
        {
            for(int j=1;j<=array.length-1-i;j++){
                if(array[j-1]>array[j]) {//swap
                    int temp=array[j-1];
                    array[j-1]=array[j];
                    array[j]=temp;
                }
            }
        }

        max=array[array.length-1];
        System.out.println("way 3 result ----");
        System.out.println("Condn. of array after 1 pass of Bubble Sort: " + Arrays.toString(array));


        System.out.println("Largest in array: " + max);

         //way 2- sort and output last index elem. -O(nlogn)
        // Sorting the array
        Arrays.sort(array);
        // Printing the sorted array
        System.out.println("Sorted Array: " + Arrays.toString(array));
        max=array[array.length-1];
        System.out.println("way 2 result ----");

        System.out.println("Largest in array: " + max);
    }
    
}

//GFG submission
// class Compute {
    
//     public int largest(int array[], int n)
//     {
//         // way 1- use max variable - O(n) - Best way
        
//         int max=array[0];
//         //System.out.println("Original array: " + Arrays.toString(array));
//         for(int i=1;i<n;i++){
//             if(array[i]>max) max=array[i];
//         }
//         return max;
        
//     }
// }

package Arrays.Easy; //q2
// Find Second Smallest and Second Largest Element in an array

import java.util.Arrays;

// 72

// 0
// Problem Statement: Given an array, find the second smallest and second largest element in the array. Print ‘-1’ in the event that either of them doesn’t exist.

// Examples
// Example 1:
// Input:
//  [1,2,4,7,7,5]
// Output:
//  Second Smallest : 2
// 	Second Largest : 5
// Explanation:
//  The elements are as follows 1,2,3,5,7,7 and hence second largest of these is 5 and second smallest is 2

// Example 2:
// Input:
//  [1]
// Output:
//  Second Smallest : -1
// 	Second Largest : -1
// Explanation:
//  Since there is only one element in the array, it is the largest and smallest element present in the array. There is no second largest or second smallest element present.
public class SecondMaxMin {

    public static void main(String[] args) {
        // way 1- use max and min variable - O(2n) 
        int[] array = {1, 8, 7, 56, 90};

        int max=array[0]; int min=max;
        System.out.println("Original array: " + Arrays.toString(array));
        // first id. the max and min elems.
        for(int i=1;i<array.length;i++){
            if(array[i]>max) max=array[i];
            if(array[i]<min) min=array[i];
        }
        System.out.println("way 1 result ----");
        System.out.println("Largest in array: " + max);
        System.out.println("Smallest in array: " + min);

        // then id. the 2nds based on above
        int secondMax=Integer.MIN_VALUE;
        int secondMin=Integer.MAX_VALUE;
        for(int i=0;i<array.length;i++){
            if(array[i]<max && array[i]>secondMax) secondMax=array[i];
            if(array[i]>min && array[i]<secondMin) secondMin=array[i];
        }
        System.out.println("2nd Largest in array: " + secondMax);
        System.out.println("2nd Smallest in array: " + secondMin);
        //op-
        //         Original array: [1, 8, 7, 56, 90]
        // Largest in array: 90
        // Smallest in array: 1
        // 2nd Largest in array: 56
        // 2nd Smallest in array: 7


        

        //way 2- Apply 2 passes of Bubble sort and give back a[2nd last index] - O(2n)
        System.out.println("way 2 result ----");
        //for 2nd largest
        for(int i=0;i<2;i++) //only 2 pass
        {
            for(int j=1;j<=array.length-1-i;j++){
                if(array[j-1]>array[j]) {//swap
                    int temp=array[j-1];
                    array[j-1]=array[j];
                    array[j]=temp;
                }
            }
        }
        secondMax=array[array.length-2];
        System.out.println("2nd Largest in array: " + secondMax);

        //for second smallest
        for(int i=0;i<2;i++) //only 2 pass
        {
            for(int j=array.length-1-2;j>=1+i;j--){//going R to L
                //-2 as I can skip checking last 2 elems as they are alredy largest 2, not gonna be smallest
                if(array[j-1]>array[j]) {//swap
                    int temp=array[j-1];
                    array[j-1]=array[j];
                    array[j]=temp;
                }
            }
        }
        secondMin=array[1];
        System.out.println("2nd Smallest in array: " + secondMin);

        //way3 - optimized way 1 - O(n)
        max=Integer.MIN_VALUE;
        min=Integer.MAX_VALUE;
        secondMax=Integer.MIN_VALUE;
        secondMin=Integer.MAX_VALUE;

        for(int j=0;j<=array.length-1;j++){
            if(array[j]>max) {
                secondMax=max; //corected seqn
                max=array[j];
                //secondMax=max; //fatal mistake
            }else if (array[j] > secondMax && array[j] != max) {
                secondMax = array[j];}

            if(array[j]<min){//w/o else if, if 1st elem is smallest, gibs wrong answer
                secondMin= min; //corected seqn
                min=array[j];
                //secondMin= min; //fatal
            }else if (array[j] < secondMin && array[j] != min) {
                secondMin = array[j];
            }
        }
        System.out.println("way 3 result ----");
        System.out.println("2nd Largest in array: " + secondMax);
        System.out.println("2nd Smallest in array: " + secondMin);
        System.out.println("Largest in array: " + max);
        System.out.println("Smallest in array: " + min);

    }
    
}

//GFG submission 
//no 1

// //User function Template for Java

// class Solution {
//     int print2largest(int array[], int n) {
//         // code here
//         int max=Integer.MIN_VALUE;
//         int secondMax=Integer.MIN_VALUE;
//         for(int j=0;j<=n-1;j++){
//             if(array[j]>max) {
//                 secondMax=max; //corected seqn
//                 max=array[j];
//                 //secondMax=max; //fatal mistake
//             }else if (array[j] > secondMax && array[j] != max) {
//                 secondMax = array[j];}
//         }
        
//         return secondMax;
//     }
// }
// Test Cases Passed: 
// 150 /271
// failed case : 
//         21
// 642 642 642 642 642 642 642 642 642 642 642 642 642 642 642 642 642 642 642 642 642
//saying op must be -1

//no 2
//User function Template for Java

// class Solution {
//     int print2largest(int array[], int n) {
//         // code here
//         int max=-1;
//         int secondMax=-1;
//         for(int j=0;j<=n-1;j++){
//             if(array[j]>max) {
//                 secondMax=max; //corected seqn
//                 max=array[j];
//                 //secondMax=max; //fatal mistake
//             }else if (array[j] > secondMax && array[j] != max) {
//                 secondMax = array[j];}
                
                
//         }
        
//         return secondMax;
//     }
// }

//question was little different, didn't read

package Arrays.Easy; //q3
// LC
// 1752. Check if Array Is Sorted and Rotated
// Easy
// Topics
// Companies
// Hint
// Given an array nums, return true if the array was originally sorted in non-decreasing order, 
// then rotated some number of positions (including zero). Otherwise, return false.

import java.util.Arrays;

// There may be duplicates in the original array.

// Note: An array A rotated by x positions results in an array B of the same length 
// such that A[i] == B[(i+x) % A.length], where % is the modulo operation.

 

// Example 1:

// Input: nums = [3,4,5,1,2]
// Output: true
// Explanation: [1,2,3,4,5] is the original sorted array.
// You can rotate the array by x = 3 positions to begin on the the element of value 3: [3,4,5,1,2].
// Example 2:

// Input: nums = [2,1,3,4]
// Output: false
// Explanation: There is no sorted array once rotated that can make nums.
// Example 3:

// Input: nums = [1,2,3]
// Output: true
// Explanation: [1,2,3] is the original sorted array.
// You can rotate the array by x = 0 positions (i.e. no rotation) to make nums.
 

// Constraints:

// 1 <= nums.length <= 100
// 1 <= nums[i] <= 100
public class sortedRotate {

    sortedRotate(int[] a){
        rotateCheck(a);
    }

    public boolean rotateCheck(int[] A){
        
            int count = 0, n = A.length;
            for (int i = 1; i < n; ++i) {
                if (A[i-1] > A[i]) {
                    count++;
                }
                if (count > 1) { //exit if count already exceed 1
                    System.out.println("Not Sorted/Roatated");
                    return false;
                }
            }
            if (A[0]<A[n-1]) count++;
            if (count > 1) {
                System.out.println("Not Sorted/Roatated");
                return false;
            }
            if (count==0) System.out.println("Sorted");
            if (count==1) System.out.println("Rotated");
            return true;
        
        

    }

    public static void main(String[] args) {
        int[] a1 = {1, 8, 7, 56, 90};
        int[] a2 = {3, 4, 5, 1, 2};
        
        System.out.println("Original array: " + Arrays.toString(a1));

        sortedRotate r1=new sortedRotate(a1);

        System.out.println("Original array: " + Arrays.toString(a2));
        sortedRotate r2=new sortedRotate(a2);
        
    }
    
}


//LC submission
// class Solution {
//     public boolean check(int[] nums) {

            
//         int count = 0, n = nums.length;
//         for (int i = 0; i < n; ++i) {
//             if (nums[i] > nums[(i + 1) % n]) {//elegant way to compare A[0]<A[n-1] within loop itself
//                 count++;
//             }
//             if (count > 1) {
//                 return false;
//             }
//         }
//         return true;
//     }
        
    
// }

//q4
// 26. Remove Duplicates from Sorted Array
// Easy
// Topics
// Companies
// Hint
// Given an integer array nums sorted in non-decreasing order, remove the duplicates in-place such that each unique element appears only once. The relative order of the elements should be kept the same. Then return the number of unique elements in nums.

// Consider the number of unique elements of nums to be k, to get accepted, you need to do the following things:

// Change the array nums such that the first k elements of nums contain the unique elements in the order they were present in nums initially. The remaining elements of nums are not important as well as the size of nums.
// Return k.
// Custom Judge:

// The judge will test your solution with the following code:

// int[] nums = [...]; // Input array
// int[] expectedNums = [...]; // The expected answer with correct length

// int k = removeDuplicates(nums); // Calls your implementation

// assert k == expectedNums.length;
// for (int i = 0; i < k; i++) {
//     assert nums[i] == expectedNums[i];
// }
// If all assertions pass, then your solution will be accepted.

 

// Example 1:

// Input: nums = [1,1,2]
// Output: 2, nums = [1,2,_]
// Explanation: Your function should return k = 2, with the first two elements of nums being 1 and 2 respectively.
// It does not matter what you leave beyond the returned k (hence they are underscores).
// Example 2:

// Input: nums = [0,0,1,1,1,2,2,3,3,4]
// Output: 5, nums = [0,1,2,3,4,_,_,_,_,_]
// Explanation: Your function should return k = 5, 
// with the first five elements of nums being 0, 1, 2, 3, and 4 respectively.
// It does not matter what you leave beyond the returned k (hence they are underscores).
 

// Constraints:

// 1 <= nums.length <= 3 * 104
// -100 <= nums[i] <= 100
// nums is sorted in non-decreasing order.
// Seen this question in a real interview before?
// 1/5
// Yes
// No
// Accepted
// 4.3M
// Submissions
// 7.7M
// Acceptance Rate
// 55.8%

package Arrays.Easy;

import java.util.Arrays;

public class removeDuplicates {
    removeDuplicates(int[]A){
        slidingRemoval(A);
    }

    private void slidingRemoval(int[] a) {
        int k=0;
        int l=0;
        int r=1;
        int i;
        int n= a.length;
        int []b=new int[n];
        //if((n>1)){

        for(i=1;i<=n;i++){
            if(a[l]!=a[r%n]){
                b[k]=a[l]; k++;
                l=r;
                r++;

            }else{
                r++;
            }
            if(r==l) {
            //     b[k]=a[l];
            //     k++;
                break;}
        }//}else{k=1;}
        if(n>0 && k==0){ 
            b[k]=a[l];
            k=1;
        }
        System.out.println("Original array: " + Arrays.toString(a));
        for(int j=0;j<n;j++){
            a[j]=b[j];
        }
        // if(n>0 && k==0){ k=1;}
        System.out.println("Mod array: " + Arrays.toString(b));
        System.out.println("Copy back array: " + Arrays.toString(a));
        System.out.println("No.of unique elems.= "+k);
    }

    public static void main(String[] args) {
        int[] arr = {1};
        removeDuplicates rd = new removeDuplicates(arr);
    }
}
//LC submission
// class Solution {
//     public int removeDuplicates(int[] nums) {
//         int k=0;
//         int l=0;
//         int r=1;
//         int i;
//         int n= nums.length;
//         int []b=new int[n];
//         for(i=1;i<=n;i++){
//             if(nums[l]!=nums[r%n]){
//                 b[k]=nums[l];k++;
//                 l=r;
//                 r++;
//             }else{
//                 r++;
//             }
//         }
        
//         for(int j=0;j<n;j++){
//             nums[j]=b[j];
//         }
//         return k;
        
//     }
// }

//Optimized LC soln
// public class Solution {
//     public int removeDuplicates(int[] nums) {
//         if (nums.length == 0) {
//             return 0;
//         }

//         int k = 1; // Initialize the count of unique elements to 1
//         for (int i = 1; i < nums.length; i++) {
//             if (nums[i] != nums[k - 1]) {
//                 nums[k] = nums[i]; // Overwrite the next unique element
//                 k++;
//             }
//         }
        
//         return k;
//     }
// }

package Arrays.Easy;
//q5 & q6
// 189. Rotate Array
// Medium
// Topics
// Companies
// Hint
// Given an integer array nums, rotate the array to the right by k steps, where k is non-negative.

 

// Example 1:

// Input: nums = [1,2,3,4,5,6,7], k = 3
// Output: [5,6,7,1,2,3,4]
// Explanation:
// rotate 1 steps to the right: [7,1,2,3,4,5,6]
// rotate 2 steps to the right: [6,7,1,2,3,4,5]
// rotate 3 steps to the right: [5,6,7,1,2,3,4]
// Example 2:

// Input: nums = [-1,-100,3,99], k = 2
// Output: [3,99,-1,-100]
// Explanation: 
// rotate 1 steps to the right: [99,-1,-100,3]
// rotate 2 steps to the right: [3,99,-1,-100]
 

// Constraints:

// 1 <= nums.length <= 105
// -231 <= nums[i] <= 231 - 1
// 0 <= k <= 105
 

// Follow up:

// Try to come up with as many solutions as you can. There are at least three different ways to solve this problem.
// Could you do it in-place with O(1) extra space?
// Seen this question in a real interview before?
// 1/5
// Yes
// No
// Accepted
// 2.1M
// Submissions
// 5.3M
// Acceptance Rate
// 40.6%
import java.util.Arrays;

public class rotatebyK {

    rotatebyK(int [] nums, int k){
        rotatebyKsteps(nums,k);
    }

    private void rotatebyKsteps(int[] nums, int k) {
        int n=nums.length;
        k=k%n;
        int [] b=Arrays.copyOfRange(nums,n-k,n);
        System.out.println("Copy b array: " + Arrays.toString(b));

        int i;
        System.out.println("Original array: " + Arrays.toString(nums));

        //for(i=0;i<n-k;i++)
        for(i=n-1-k;i>=0;i--)
        {
            nums[i+k]=nums[i];
        }
        for(i=0;i<k;i++){
            nums[i]=b[i];
        }
        System.out.println("Mod array: " + Arrays.toString(nums));

        
    }

    public static void main(String[] args) {
        int[] arr = {1,2,3,4,5,6,7}; int k=3;
        rotatebyK rd = new rotatebyK(arr,k);
    }
    
}
//lc submission
        // int n=nums.length;
        // k=k%n;
        // int [] b=Arrays.copyOfRange(nums,n-k,n);

        // int i;

        // for(i=n-1-k;i>=0;i--)
        // {
        //     nums[i+k]=nums[i];
        // }
        // for(i=0;i<k;i++){
        //     nums[i]=b[i];
        // }
//lc fast soln
// class Solution {
//     public void rotate(int[] nums, int k) {
//         k = k % nums.length;   
//         // find reminder of k divided by nums.length because k is more than nums.length we don't need to iterate huge iterations.
//         reverse(nums,0,nums.length-1);  // first of all reverse entire the array.
//         reverse(nums,0,k-1);   // reverse the array from 0th index to k-1 index.
//         reverse(nums,k,nums.length-1);   // reverse the array from kth index to araay.length-1 index.
//     }
//     void reverse(int[] nums,int i,int j){   // Create a reverse function to reverse array from ith position to jth position.
//         while(i<j){
//             swap(nums,i,j);
//             i++;
//             j--;
//         }
//     }
//     void swap(int[] nums,int i,int j){   // Create a swap function to swap to array elements.
//         int temp = nums[i];
//         nums[i] = nums[j];
//         nums[j] = temp;
//     }
// }

package Arrays.Easy;
//q7
// 283. Move Zeroes
// Solved
// Easy
// Topics
// Companies
// Hint
// Given an integer array nums, move all 0's to the end of it while maintaining the relative order of the non-zero elements.

// Note that you must do this in-place without making a copy of the array.

 

// Example 1:

// Input: nums = [0,1,0,3,12]
// Output: [1,3,12,0,0]
// Example 2:

// Input: nums = [0]
// Output: [0]
 

// Constraints:

// 1 <= nums.length <= 104
// -231 <= nums[i] <= 231 - 1
 

// Follow up: Could you minimize the total number of operations done?
// Seen this question in a real interview before?
// 1/5
// Yes
// No
// Accepted
// 3M
// Submissions
// 4.8M
// Acceptance Rate
// 61.8%
import java.util.Arrays;

public class moveZeroes {

    moveZeroes(int nums[])
    {
        moveZeroesToEnd(nums);
    }

    private void moveZeroesToEnd(int[] nums) {
        int k=0; int n=nums.length;
        System.out.println("Original array: " + Arrays.toString(nums));
        for(int i=0;i<n;i++){
            if(nums[i]!=0) nums[k++]=nums[i];
        } 
        System.out.println("Intermediate array: " + Arrays.toString(nums));
        for(int i=k;i<n;i++) nums[i]=0;
        System.out.println("Final array: " + Arrays.toString(nums));
    }

    public static void main(String[] args) {
        int[] arr = {0};//{1,0,2,3,4,0,5,6,7};
        moveZeroes rd = new moveZeroes(arr);
    }

    
}
//lc submission
// class Solution {
//     public void moveZeroes(int[] nums) {
//         int k=0; int n=nums.length;
//         for(int i=0;i<n;i++){
//             if(nums[i]!=0) nums[k++]=nums[i];
//         } 
//         for(int i=k;i<n;i++) nums[i]=0;
        
//     }
// }

//lc snowball approach
// class Solution {
//     public void moveZeroes(int[] nums) {
//        int snowBallSize = 0; 
//        for (int i=0;i<nums.length;i++){
//            if (nums[i]==0){
//                snowBallSize++; 
//            }
//            else if (snowBallSize > 0) {
            //    int t = nums[i];//
            //    nums[i]=0;//
            //    nums[i-snowBallSize]=t;//
    //         nums[i-snowBallSize]=nums[i];
    // nums[i]=0;
//            }
//        }
//    }
// }

//lc 2 ptr soln
// class Solution {
//     public void moveZeroes(int[] nums) {
//         int left = 0;

//         for (int right = 0; right < nums.length; right++) {
//             if (nums[right] != 0) {
                   //swap 
//                 int temp = nums[right];
//                 nums[right] = nums[left];
//                 nums[left] = temp;
//                 left++;
//             }
//         }        
//     }
// }

package Arrays.Easy;
//q8
// Searching an element in a sorted array
// BasicAccuracy: 48.03%Submissions: 184K+Points: 1
// Find better job opportunities this summer via Job-A-Thon Hiring Challenge!


// banner
// Given an array arr[] sorted in ascending order of size N and an integer K. Check if K is present in the array or not.


// Example 1:

// Input:
// N = 5, K = 6
// arr[] = {1,2,3,4,6}
// Output: 1
// Exlpanation: Since, 6 is present in 
// the array at index 4 (0-based indexing),
// output is 1.
 

// Example 2:

// Input:
// N = 5, K = 2
// arr[] = {1,3,4,5,6}
// Output: -1
// Exlpanation: Since, 2 is not present 
// in the array, output is -1.
 

// Your Task:
// You don't need to read input or print anything. Complete the function searchInSorted() which takes the sorted array arr[], its size N and the element K as input parameters and returns 1 if K is present in the array, else it returns -1. 


// Expected Time Complexity: O(Log N)
// Expected Auxiliary Space: O(1)

 

// Constraints:
// 1 <= N <= 106
// 1 <= K <= 106
// 1 <= arr[i] <= 106
public class Search {


    Search(){

    }

    public static int BinSrch(int a[],int k)
    {
        int l=0;
        int r=a.length-1;
        while (l<=r) 
        {   
            int m=l+(r-l)/2;
            if(a[m]==k) return m;
            if(a[m]<k) l=m+1;
            else r=m-1;
        }
        return -1;

    }
    public static int InterSrch(int a[],int k)
    {   //Can gib arithmetic exception if there are repeated values in sorted array due to division in m formula
        int l=0;
        int r=a.length-1;
        while (l<=r) 
        {
            int m=l+((k-a[l])/(a[r]-a[l]))*(r-l);
            
            if(a[m]==k) return m;
            if(a[m]<k) l=m+1;
            else r=m-1;
        }
        return -1;
    }
    public static int LinSrch(int a[], int k){
        for(int i=0;i<a.length;i++){
            if(a[i]==k) return k;
            if(a[i]>k) return -1;
        }
        return -1;
    }

    public static void main(String[] args) {
        int[] arr = {-101,10,22,35,47,58,69,73,86,420,42069};
        int k = 86;
    
        //Search rd = new Search();

        //int srchI=Search.BinSrch(arr, k);
        System.out.println(Search.BinSrch(arr, k));
        System.out.println(Search.InterSrch(arr, k));
    }
    
}
//modified methods that gib no. of iterations

// public static int BinSrch(int a[],int k)
// {
//     int l=0;
//     int r=a.length;
//     int i=0;
//     while (l<=r) 
//     {   i++;
//         int m=l+(r-l)/2;
//         if(a[m]==k) return i;//m;
//         if(a[m]<k) l=m+1;
//         else r=m-1;
//     }
//     return i;//-1;

// }
// public static int InterSrch(int a[],int k)
// {
//     int l=0;
//     int r=a.length-1;
//     int i=0;
//     while (l<=r) 
//     {
//         i++;
//         int m=l+((k-a[l])/(a[r]-a[l]))*(r-l);
        
//         if(a[m]==k) return i;//m;
//         if(a[m]<k) l=m+1;
//         else r=m-1;
//     }
//     return i;//-1;
// }
// public static int LinSrch(int a[], int k){
//     for(int i=0;i<a.length;i++){
//         if(a[i]==k) return k;
//         if(a[i]>k) return -1;
//     }
//     return -1;
// }

//gfg submission
// class Solution{
//     static int searchInSorted(int a[], int N, int k)
//     {
        
//         // Your code here
//         int l=0;
//         int r=N-1;
//         while (l<=r) 
//         {   
//             int m=l+(r-l)/2;
//             if(a[m]==k) return 1;
//             if(a[m]<k) l=m+1;
//             else r=m-1;
//         }
//         return -1 ;       
//     }
// }


package Arrays.Easy;
import java.util.Arrays;
//q10
public class MissingNo {

    MissingNo(){}

    public static int missingNo(int[]nums){
        int n=nums.length;

        int g=((n)*(n+1))/2;

        //for(int i) no need to iterate, stream is my new best friend tho he is slow
        int sum = Arrays.stream(nums).sum();
        System.out.println("The sum of the numbers in the array is: " + sum);
        return g-sum;
    }



    public static void main(String[] args) {
        int[] arr = {0,1,3,4,5};
        int k = 86;
        int missing=MissingNo.missingNo(arr);
        System.out.println("missing no.= "+ missing);
    
        
    }
    
}
//lc submission
// class Solution {
//     public int missingNumber(int[] nums) {
//                 int n=nums.length;

//         int g=((n)*(n+1))/2;

//         int sum = 0;
//         for(int i=0;i<n;i++){
//             sum+=nums[i];
//         }
//         return g-sum;

//     }
// }

//lc iterator soln
// class Solution {
//     public int missingNumber(int[] nums) {
//         int n = nums.length;
//         boolean[] check = new boolean[nums.length + 1];
//         for (int num : nums) {
//             check[num] = true;
//         }
//         for (int i = 0; i < n; i++) {
//             if (!check[i]) {
//                 return i;
//             }
//         }
//         return n;
//     }
// }

// XOR lc submission
// class Solution {
//     public int missingNumber(int[] nums) {
//         int n = nums.length;
//         int ans = 0;
//         for (int i = 0; i <= n-1; i++) {
//             ans = ans ^ i ^ nums[i];
//         }
        
//             ans = ans ^ n;
        
//         return ans;

//     }
// }

package Arrays.Easy;
//q9
// Union of Two Sorted Arrays
// MediumAccuracy: 31.39%Submissions: 205K+Points: 4
// Find better job opportunities this summer via Job-A-Thon Hiring Challenge!

import java.util.ArrayList;
import java.util.Arrays;

// banner
// Given two sorted arrays of size n and m respectively, find their union. The Union of two arrays can be defined as the common and distinct elements in the two arrays. Return the elements in sorted order.

// Example 1:

// Input: 
// n = 5, arr1[] = {1, 2, 3, 4, 5}  
// m = 5, arr2 [] = {1, 2, 3, 6, 7}
// Output: 
// 1 2 3 4 5 6 7
// Explanation: 
// Distinct elements including both the arrays are: 1 2 3 4 5 6 7.
// Example 2:

// Input: 
// n = 5, arr1[] = {2, 2, 3, 4, 5}  
// m = 5, arr2[] = {1, 1, 2, 3, 4}
// Output: 
// 1 2 3 4 5
// Explanation: 
// Distinct elements including both the arrays are: 1 2 3 4 5.
// Example 3:

// Input:
// n = 5, arr1[] = {1, 1, 1, 1, 1}
// m = 5, arr2[] = {2, 2, 2, 2, 2}
// Output: 
// 1 2
// Explanation: 
// Distinct elements including both the arrays are: 1 2.
// Your Task: 
// You do not need to read input or print anything. Complete the function findUnion() that takes two arrays arr1[], arr2[], and their size n and m as input parameters and returns a list containing the union of the two arrays.

// Expected Time Complexity: O(n+m).
// Expected Auxiliary Space: O(n+m).

// Constraints:
// 1 <= n, m <= 105
// -109 <= arr1[i], arr2[i] <= 109
import java.util.ArrayList;

public class unionArrays {
//works but time out on gfg due to continual use of list.contains()- increases TC
    // public static ArrayList<Integer> unionOf2Arrays(int []a,int[]b){
    //     int m=a.length;
    //     int n=b.length;
    //     ArrayList<Integer> list = new ArrayList<>();
    //     int i=0;
    //     int j=0;
    //     int k=0;
    //     while (i<m && j<n){
    //         if(a[i]==b[j]){
    //             if (!list.contains(a[i])) {
    //                 list.add(a[i]);
    //             }
    //             ++k;++i;++j;
    //         }
    //         else if(a[i]>b[j]){
    //             if (!list.contains(b[j])) {
    //                 list.add(b[j]);
    //             }
    //             ++k;++j;
    //         }
    //         else if(a[i]<b[j]){
    //             if (!list.contains(a[i])) {
    //                 list.add(a[i]);
    //             }
    //             ++k;++i;
    //         }
    // }
    // while (i>=m && j<n) {
    //     if (!list.contains(b[j])) {
    //         list.add(b[j]);
    //     }
    //     ++j;++k;
    // }
    // while (j>=n && i<m){
    //     if (!list.contains(a[i])) {
    //         list.add(a[i]);
    //     }
    //     ++i;++k;
    // }
    // System.out.println("No. of elems. in union:"+k);
    // return list;
// }
    public static void main(String[] args) {
        int[] a1 = {-1,-1,3,3,4,5};
        int[] a2 = {-1,-2,3};
        
        System.out.println("Original array: " + Arrays.toString(a1));

        //sortedRotate r1=new sortedRotate(a1);

        System.out.println("Original array: " + Arrays.toString(a2));
        //sortedRotate r2=new sortedRotate(a2);
        ArrayList<Integer> list = findUnion(a1, a2,a1.length,a2.length);
        System.out.println(list.toString());
    }
    public static ArrayList<Integer> findUnion(int a[], int b[], int m, int n)
    {
         ArrayList<Integer> list = new ArrayList<>();
        int i=0;
        int j=0;int last;
        while (i<m && j<n){
            //if(list.size()!=0) last= list.get(list.size()-1);//causes compilation errors
            if(a[i]<=b[j]){
                if (list.size()==0||list.get(list.size()-1)!=a[i]) {
                    list.add(a[i]);
                }
                ++i;//++j; //causes reps. why?
            }
            else //if(a[i]>b[j]){
                {if (list.size()==0||list.get(list.size()-1)!=b[j]) {
                    list.add(b[j]);
                }
                ++j;
            }
            // else {
            //     if (list.size()==0||list.get(list.size()-1)!=a[i]) {
            //         list.add(a[i]);
            //     }
            //     ++i;
            // }
    }
    while (j<n) {
        //last= list.get(list.size()-1);
        if (list.get(list.size()-1)!=b[j]) {
            list.add(b[j]);
        }
        ++j;
    }
    while (i<m){
        //= list.get(list.size()-1);
        if (list.get(list.size()-1)!=a[i]) {
            list.add(a[i]);
        }
        ++i;
    }
    
    return list;

    }
}

//gfg submission
//     //User function Template for Java

// //arr1,arr2 : the arrays
// // n, m: size of arrays
// class Solution
// {
//     //Function to return a list containing the union of the two arrays.
//     public static ArrayList<Integer> findUnion(int a[], int b[], int m, int n)
//     {
//          ArrayList<Integer> list = new ArrayList<>();
//         int i=0;
//         int j=0;
//         while (i<m && j<n){

//             if(a[i]<=b[j]){
//                 if (list.size()==0||list.get(list.size()-1)!=a[i]) {
//                     list.add(a[i]);
//                 }
//                 ++i;
//             }
//             else 
//                 {if (list.size()==0||list.get(list.size()-1)!=b[j]) {
//                     list.add(b[j]);
//                 }
//                 ++j;
//             }
//     }
//     while (j<n) {

//         if (list.get(list.size()-1)!=b[j]) {
//             list.add(b[j]);
//         }
//         ++j;
//     }
//     while (i<m){
 
//         if (list.get(list.size()-1)!=a[i]) {
//             list.add(a[i]);
//         }
//         ++i;
//     }
    
//     return list;

// }
// }





package Arrays.Easy;
//q12
// 136. Single Number
// Easy
// Topics
// Companies
// Hint
// Given a non-empty array of integers nums, every element appears twice except for one. Find that single one.

import java.util.HashMap;

// You must implement a solution with a linear runtime complexity and use only constant extra space.

 

// Example 1:

// Input: nums = [2,2,1]
// Output: 1
// Example 2:

// Input: nums = [4,1,2,1,2]
// Output: 4
// Example 3:

// Input: nums = [1]
// Output: 1
 

// Constraints:

// 1 <= nums.length <= 3 * 104
// -3 * 104 <= nums[i] <= 3 * 104
// Each element in the array appears twice except for one element which appears only once.
// Seen this question in a real interview before?
// 1/5
// Yes
// No
// Accepted
// 2.8M
// Submissions
// 3.8M
// Acceptance Rate
// 72.9%
public class singleNo {
    
    public static int singleNumber(int[] nums) {//hm soln
        // HashMap<Integer,Integer> EF= new HashMap<>();
        // int i;
        // int L=nums.length;
        // for(i=0;i<L;i++){
        //     if(EF.containsKey(nums[i])){
        //         //if elem already prsnt overwrt its freq by incremented freq
        //         EF.put(nums[i],EF.get(nums[i])+1);
        //     }else{//if elem not prsnt, add with freq=1
        //         EF.put(nums[i],1);
        //     }
        // }
        // int keyi=-1;int f;
        // for (int key : EF.keySet()) {
        //     f = EF.get(key);
        //     if(f<2) {
        //         keyi=key;
        //         return keyi;
        //     }
            
        // }return keyi;

        // XOR soln, fastr
        int n = nums.length;

        // XOR all the elements:
        int ans = 0;
        for (int i = 0; i < n; i++) {
            ans = ans ^ nums[i];
        }
        return ans;
    }
    public static void main(String[] args) {
        int[] arr = {0,0,1};
        //int k = 86;
        int sn=singleNo.singleNumber(arr);
        System.out.println("single no. = "+ sn);
    
        
    }
    
}
//lc hashmap soln submission, took lot of time
// class Solution {
//     public int singleNumber(int[] nums) {
//                 HashMap<Integer,Integer> EF= new HashMap<>();
//         int i;
//         int L=nums.length;
//         for(i=0;i<L;i++){
//             if(EF.containsKey(nums[i])){
//                 EF.put(nums[i],EF.get(nums[i])+1);
//             }else{
//                 EF.put(nums[i],1);
//             }
//         }
//         int keyi=-1;int f;
//         for (int key : EF.keySet()) {
//             f = EF.get(key);
//             if(f<2) {
//                 keyi=key;
//                 return keyi;
//             }
            
//         }return keyi;

        
//     }
// }

//lc XOR submission

// class Solution {
//     public int singleNumber(int[] nums) {
//         int n = nums.length;
//         int ans = 0;
//         for (int i = 0; i < n; i++) {
//             ans = ans ^ nums[i];
//         }
//         return ans; 
        
//     }
//}

//q13&14 same with some difference that changes optimal strategies
/*
 * Longest Sub-Array with Sum K
MediumAccuracy: 24.64%Submissions: 232K+Points: 4
Find better job opportunities this summer via Job-A-Thon Hiring Challenge!

banner
Given an array containing N integers and an integer K., Your task is to find the length of the longest Sub-Array with the sum of the elements equal to the given value K.

 

Example 1:
 

Input :
A[] = {10, 5, 2, 7, 1, 9}
K = 15
Output : 4
Explanation:
The sub-array is {5, 2, 7, 1}.
Example 2:

Input : 
A[] = {-1, 2, 3}
K = 6
Output : 0
Explanation: 
There is no such sub-array with sum 6.
Your Task:
This is a function problem. The input is already taken care of by the driver code. You only need to complete the function lenOfLongSubarr() that takes an array (A), sizeOfArray (n),  sum (K)and returns the required length of the longest Sub-Array. The driver code takes care of the printing.

Expected Time Complexity: O(N).
Expected Auxiliary Space: O(N).

 

Constraints:
1<=N<=105
-105<=A[i], K<=105
 
 * 
 */

package Arrays.Easy;

import java.util.HashMap;
import java.util.Map;

public class lengthOfLongestSubArray {

    // Function for finding maximum and value pair
    public static int lenOfLongSubarr (int A[], int N, int k) {
        // //Complete the function
        //Only works for positive nos. - O(n)
        // int l=0;int r=0; int cnt=0; int max=0; int sum=0;
        // while(r<N){
        //     sum+=A[r];
        //     if(sum<k) {
        //         r++;
        //         //sum+=A[r-1];
        //     }
        //     else if(sum>k){
        //         l++;
        //         //l=r;//fatal
        //         r=l;
        //         sum=0;
        //     }
        //     else if(sum==k){
        //         //r++;
                
        //         cnt=r-l+1;
        //         max=(max<cnt)? cnt:max;
        //         cnt=0;sum=0;
        //         l++;
        //         //l=r;//fatal
        //         r=l;

        //     }
            
        // }return max;


        // workd for negatives as well - O(nlogn)
        Map<Integer, Integer> HM = new HashMap<>();
        int sum = 0;
        int maxu = 0;
        for (int i = 0; i < N; i++) {
            //calc. the prefix sum till index i
            sum += A[i];

            // if the sum = k, update the maxu
            if (sum == k) {
                maxu = Math.max(maxu, i + 1);
            }

            // calc. the sum of remaining part, that is,= x-k
            int rem = sum - k;

            //calc. the length and update maxu
            if (HM.containsKey(rem)) {
                int len = i - HM.get(rem);
                maxu = Math.max(maxu, len);
            }

            //update the map checking the conditions
            if (!HM.containsKey(sum)) {
                HM.put(sum, i);
            }
        }

        return maxu;

    }
    public static void main(String[] args) {
        int[] arr = {1,15,1,1,1,1,1,1,1,1,1,1,2,1,2,2,2,2,2,2,2,1,1,1,1,1,1,1,1,1};//{10,5,2,7,1,9};
        int k = 15;
        int maxs=lengthOfLongestSubArray.lenOfLongSubarr(arr,arr.length,k);
        System.out.println("len of largest subarr to sum "+ k +" = "+ maxs);//4

        int a[]={1, 4, 3, 3, 5, 5};
        int ka=16;
        int maxs1=lengthOfLongestSubArray.lenOfLongSubarr(a,a.length,ka);
        System.out.println("len of largest subarr to sum "+ ka +" = "+ maxs1); //5
    
        
    }

}

// //gfg submission
// Map<Integer, Integer> HM = new HashMap<>();
// int sum = 0;
// int maxu = 0;
// for (int i = 0; i < N; i++) {
//     //calc. the prefix sum till index i
//     sum += A[i];

//     // if the sum = k, update the maxu
//     if (sum == k) {
//         maxu = Math.max(maxu, i + 1);
//     }

//     // calc. the sum of remaining part, that is,= x-k
//     int rem = sum - k;

//     //calc. the length and update maxu
//     if (HM.containsKey(rem)) {
//         int len = i - HM.get(rem);
//         maxu = Math.max(maxu, len);
//     }

//     //update the map checking the conditions
//     if (!HM.containsKey(sum)) {
//         HM.put(sum, i);
//     }
// }

// return maxu;


//q11
// 485. Max Consecutive Ones
// Solved
// Easy
// Topics
// Companies
// Hint
// Given a binary array nums, return the maximum number of consecutive 1's in the array.

 

// Example 1:

// Input: nums = [1,1,0,1,1,1]
// Output: 3
// Explanation: The first two digits or the last three digits are consecutive 1s. The maximum number of consecutive 1s is 3.
// Example 2:

// Input: nums = [1,0,1,1,0,1]
// Output: 2
 

// Constraints:

// 1 <= nums.length <= 105
// nums[i] is either 0 or 1.
// Seen this question in a real interview before?
// 1/5
// Yes
// No
// Accepted
// 1.2M
// Submissions
// 2M
// Acceptance Rate
// 59.1%


package Arrays.Easy;


public class maxConsec1s {

    public static int findMaxConsecutiveOnes(int[] nums) {
        int r=0; int cnt=0; int max=0; int n=nums.length;
        while(r<n){
            if(nums[r]==1) cnt++;
            else cnt=0;
            max=(cnt>max)?cnt:max;
            r++;
        }return max;

        
    }
    public static void main(String[] args) {
        int[] arr = {0,1,1,0,0,1,1,1,0};
        //int k = 86;
        int max1s=maxConsec1s.findMaxConsecutiveOnes(arr);
        System.out.println("max. consec. 1's = "+ max1s);
    
        
    }
}

//lc submission 1
// class Solution {
//     public int findMaxConsecutiveOnes(int[] nums) {
//                 int l=0; int r=0; int cnt=0; int max=0; int n=nums.length;
//         while(r<n){
//             if(nums[l]==nums[r]){
//                 r++;
//                 if(nums[r-1]==1) cnt++;
//                 if(cnt>max) {max=cnt; }
//             }else{
//                 l=r;
               
//                 cnt=0;
//             }
//         }return max;

//     }
//}

//lc submission 2

// class Solution {
//     public int findMaxConsecutiveOnes(int[] nums) {
//         int r=0; int cnt=0; int max=0; int n=nums.length;
//         while(r<n){
//             if(nums[r]==1) cnt++;
//             else cnt=0;
//              max=(cnt>max)?cnt:max;

//             r++;
//         }return max;

//     }
// }

// lc soln by sb else, little faster due to some reason
// class Solution {
//     public int findMaxConsecutiveOnes(int[] nums)
//     {
//         // Initialize variables to track the maximum count and current count of consecutive 1s
//         int maxCount=0;
//         int curCount=0;

//         // Iterate through each element in the array
//         for(int element: nums){
//             if(element==0){
//         //reset curCount and maxCount whenever 0 is encountered.
//                 if(maxCount<curCount){
//                     maxCount=curCount;
//                 }
//                 curCount=0;                
//             }
//             else{
//                 curCount++;
//             }
//         }
//         // After the loop, compare the final current count with the maximum count and return the larger value
//         return maxCount>curCount? maxCount:curCount;
        
//     }
// }

//lc submission 3, takes little lesser memory replacing if with ?
// class Solution {
//     public int findMaxConsecutiveOnes(int[] nums)
//     {
//         int maxCount=0;
//         int curCount=0;

//         for(int element: nums){
//             if(element==0){  
//                 maxCount=(maxCount<curCount)?curCount:maxCount;
//                 curCount=0;                
//             }
//             else{
//                 curCount++;
//             }
//         }
//         return maxCount>curCount? maxCount:curCount;
        
//     }
// }